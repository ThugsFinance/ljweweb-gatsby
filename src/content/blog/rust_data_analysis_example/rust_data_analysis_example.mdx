---
title: "React Data Analysis Example"
tags: ["Rust", "Data Science", "reqwest", "serde", "Serialization", "HTTP"]
date: "2022-01-10"
---
# Exploring `Rust` through a data science perspective

<img src="https://rustacean.net/assets/rustacean-flat-happy.png" width="540px"/>

> **Rust provides C/C++ comparable speed** with improved tooling and an aggressive compiler
that enforces sound code patterns.



I want to write an example to show how one could go about doing a simple data analysis
exercise in [__Rust__](https://www.rust-lang.org/). The task we are going to be performing is ingesting some data external
JSON over HTTP. Specifically, we are going to be calling an endpoint containing stock information about
[__IBM__](https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=IBM&interval=5min&apikey=demo),
provided by [AlphaVantage](https://www.alphavantage.co/).

---

For those who do not know what __Rust__ is, it`s a relatively new systems programming language.
**Rust provides C/C++ comparable speed** with improved tooling and an aggressive compiler
that enforces sound code patterns.

For this example, we will use two popular __Rust__ libraries: `serde` & `reqwest`.
Typically, these dependency definitions would go into _Cargo.toml_, but since this
code is running in a jupyter kernel, we declare them in our code.

```rust
:dep reqwest = "0.10"
:dep serde_json
:dep serde = { version = "1.0", features = ["derive"] }

use serde_json::Value;
use std::collections::HashMap;
use serde::{Serialize, Deserialize, Deserializer, de};
```

## [reqwest](https://docs.rs/reqwest/latest/reqwest/)

A fairly simple library that will allow us to make HTTP requests in a straightforward
manner, similar to the requests module in Python. We await this request (since there’s
no guarantee it succeeds), then await the extraction of the text from the response
(since there’s no guarantee that succeeds either).

```rust
let request = reqwest::get("https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=IBM&interval=5min&apikey=demo").await?.text().await?;
```

> **Note**: the [`?` operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)

## [serde](https://serde.rs/)

We want to parse the returned JSON string and return it in a format that is usable for
our purposes. This process, called `Serialization/Deserialization`, is implemented in
__Rust__ using the `serde` crate. We can de-serialize this result using the following command:

```rust
let request = reqwest::get("https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=IBM&interval=5min&apikey=demo").await?.text().await?;
let deser_resp: Value = serde_json::from_str(&request)?;
println!("{:?}", deser_resp)
```

However, you may notice that the prices are being encoded as a string -- Why is this?

## Typed deserialization

This is because we have yet to properly type the data. In addition, there is some
accompanying metadata that we will need to worry about.

To simplify the conversion of this data, we will define some structs that act as models
for our deserializer.

```rust
#[derive(Debug, Deserialize, Serialize)] // ! Generate default serialization/deserialization traits
struct DataFeed {
    // ! The JSON keys provided to us contain whitespace and other characters
    // ! that we cannot use in a struct block. To work around this, we define an alias
    // ! for each field that matches the JSON key
    #[serde(alias = "Meta Data")]
    meta_data: HashMap<String, String>, // ! Desired Rust type(s)

    #[serde(alias = "Time Series (5min)")]
    time_series: HashMap<String, Bar>
}

#[derive(Debug, Deserialize, Serialize)]
struct Bar {
    #[serde(alias = "1. open")]
    #[serde(deserialize_with = "de_rating")] // ! Deserialize using function (below)
    open: f32,

    #[serde(alias = "2. high")]
    #[serde(deserialize_with = "de_rating")]
    high: f32,

    #[serde(alias = "3. low")]
    #[serde(deserialize_with = "de_rating")]
    low: f32,

    #[serde(alias = "4. close")]
    #[serde(deserialize_with = "de_rating")]
    close: f32,

    #[serde(alias = "5. volume")]
    #[serde(deserialize_with = "de_rating")]
    volume: f32
}
```

Then, we implement the serialization function. Though the
signature is quite daunting, this function is relatively simple.

```rust
// ! credit to reddit user 'exoticorn' for this snippet
// https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=ee7f582b5873013723596790a7993925
fn de_rating<'de, D: Deserializer<'de>>(deserializer: D) -> Result<f32, D::Error> {
    Ok(match Value::deserialize(deserializer)? {
        Value::String(s) => s.parse().map_err(de::Error::custom)?,
        Value::Number(num) => num.as_f64().ok_or(de::Error::custom("Invalid number"))? as f32,
        _ => return Err(de::Error::custom("wrong type"))
    })
}
```

When it is called, each value will be taken, and __Rust__ is going to ask: _Was this parsed as a string?_
If so, it will be parsed as an `f32` float (due to being specified in
the function's `Result`). Then, __Rust__ is going to ask: _Was this parsed as a number?_
This is irrelevant in our case since it was all parsed as strings, but is useful for
demonstration purposes. Finally, `_` tells __Rust__ to return an error in all other cases.

---

Just like that, we have implemented strongly-typed JSON serialization in __Rust__! To further
extend this implementation, one could add an alternative serialization for the volume
category since it should actually be an integer instead of a float (stocks quantities are not
fractional). In addition, the string timestamp key for the time_series hash map could be parsed
using something like `chrono`.
